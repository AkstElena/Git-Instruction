# ***`Основные команды и последовательности при работе с Git`***

 ## **1. Первоначальные действия**

* **git config --global user.name "your name"** - make a record in config of your name (делается один раз, в дальнейшем система уже будет его использоваться)

* **git config --global user.email "your email"** - make a record in config of your email (делается один раз, в дальнейшем система уже будет его использоваться)

* **git --version** - установлен ли git в системе, какая версия

* **git init**  - запуск иницианализации (если папка стала репозиторием, то созаднные внутри папки нельзя инициоровать, они и так уже в репозитории)

## **2. Команды для работы**

* **git add .** - track all files in git

* **git add "file name"** - track one file in git (указывать название с расширением)

* **git status** - show status: branch, quantity of commit (статус папки, создан ли репозиторий, есть ли коммиты)

* **git commit -m "massege"** - indicate changes in project (commit - фиксация)

* **git commit -am "massege"** - let us avold using git add again (одновременно и добавить и прокомментировать, но уже добавленные файлы)         

* **cd "folder name"** - позволяет перейти на необходимую папку, для дальнейшей работы с ней

* **git log** - выводит данные о всех имеющихся версиях, в порядке от последней, с указанием номера коммита

* **git log --graph** - данные о версиях графически, с наглядным изображением всех веток

* **Q** - выйти в терминал из режима просмотра git log (иногда не срабатывает, т.к. был нажать ctrl+C. Надо заново нажать, все заработает)

* **git checkout "4 first simbols"** -указывает вариант сохранения, достаточно четырех первых знака версии, чтобы вывести ее

* **git checkout master/main** - возврат в основную ветку

* **Cntrl+S** - сохранить файл (несохраненные изменения показываются наличием белой точки раядом с названием файла)

* **git reset** - используется для отмены коммита или проиндексированного снимка состояния

* **git reset --hard "simbols of commit"** - история коммитов будет сброшена до указанного коммита. Отлично подходит для локальных изменений, но в общем удаленном репозитории система Git обнаружит отсутствие коммитов и выдаст ошибку. 

* **git revert** - безопаснее, чем reset, так как она не удаляет коммиты из общей истории. Она сохраняет отменяемые коммиты и создает новый коммит с операцией, обратной последнему коммиту. Подходит для работы с удаленным репозиторием

* **git commit --amend** - используется если коммит сделан преждевременно. В этом случае его можно исправить. Для этого после  внесения дополнительных изменений в рабочий каталог и добавления их с помощью команды git add, вводим указанную выше команду. Git откроет настроенный системный редактор, где можно будет изменить комментарий к последнему коммиту. Новые изменения будут добавлены в исправленный коммит

* **git revert HEAD** - Git создаст новый коммит с операцией, обратной последнему коммиту

* **git diff** - show differences between actual state and last commit, используется для вычисления разницы между любыми двумя Git-деревьями. Это может быть разница между вашей рабочей копией и индексом, разница между индексом и последним коммитом (**git diff --staged**), или между любыми двумя коммитами (**git diff master branchB**). При внесение изменений "-" и красным показано удаление, "+" и зеленое добавление

* **git branch** - показывает имеющиеся ветки с выделением той, на которой находится сейчас

* **git branch название_ветки /git checkout -b название_ветки** - создание новой ветки

* **git checkout название_ветки** - переключение между ветками

* **git branch -d название_ветки** - для удаления уже слитой ветки

* **git branch -D название_ветки** - для удаления неслитой ветки

* **git help** - служит для отображения встроенной документации Git о других командах

* **git merge наименование_ветки** - используется для слияния одной или нескольких веток в текущую (после слияния итоговый файл остается в текущей ветке, а не в той, которая указана в команде)

При слиянии веток может возникнуть конфликт (изменения в одних и тех же строках в разных ветках). Часть конфликтов Git решает сам, например точки, пробелы, абзацы и т.п. Если же не может решить, то выдаст окно для решения проблемы. В нем можно принять текущий (current) вариант (из основной ветки), входящий (incoming) вариант (от сливаемой ветки), либо оба (both)

* **clear** - очистить терминал

## **3. Последовательность операций**

Работаем в созданном репозитории

|Номер пункта| Действия|
|------------|:--------|
|1.| Добавляем файл|
|2.| Делаем изменения в файле|
|3. |Трекаем файл (git add)|
|4. |Делаем коммит (git commit -m)|
|5. |Делаем изменения|
|6. |Трекаем файл|
|7. |Делаем новый коммит|

Однако вместо пунктов 6 и 7 можно сразу

6. Трекаем файл и добавляем коммит (git commit -am)

## **4. Работа c GitHub**

*Git* - это программа на компьютере

*GitHub* - сервис, который интегрируется с Git-программой и позволят настроить удаленную работу с репозиториями

* **git clone адрес_с_GitHub** - добавляет из GitHub (работает как обёртка над некоторыми другими командами. Она создаёт новый каталог, переходит внутрь и выполняет git init для создания пустого репозитория, затем добавляет новый удалённый репозиторий (**git remote add**) для указанного URL (по умолчанию он получит имя origin), выполняет **git fetch** (получение изменений с сервера) для этого репозитория и, наконец, извлекает последний коммит в ваш рабочий каталог, используя git checkout)

Если запросить статус после клонирования, то покажет что репозитория нет. Это связано с тем, что в репозиторий был установлен полностью в указанную папку целой папкой. Такми образом, для работы с репозиторием нужно просто перейти в новую папку внутри исходной.

Если же необходимо направить локальный репозиторий на GitHub, то необходимо создать на GitHub новый репозиторий, затем:

1. **git remote add origin URL** - указываем адрес
2. **git branch -M main** - указываем что это главная ветка
3. **git push -u origin main** - направляет все что сделано локально в удаленный репозиторий

* **git push**  - отправить на github. Позволяет только в том случае, если репозиторий на GitHub принадлежит тому, кто отправляет

* **git fetch** - связывается с удалённым репозиторием, забирает из него все изменения, которых пока нет локально и сохраняет их

* **git pull** - обновляем текущую ветку с сервера (работает как комбинация команд git fetch и git merge, т. е. Git вначале забирает изменения из указанного удалённого репозитория, а затем пытается слить их с текущей веткой). В случае конфликта нужно будет его решить.

В GitHub много публичных репозиториев, где можно взять файлы:
- клонировать локально
- создать *fork* ("вилку") на удаленном репозитории, затем затянуть себе локально

"Вилка" нужна для того, чтобы создав в нем новую ветку, предложить решение задач для владельца репозитория, не изменяя исходный код.

* **pull request** - позволяет направить свое предложение по изменению проекта владельцу репозитория

# ***`Ошибки возникающие при работе с Git. Советы и заметки`***

Не стоит после каждого изменения файла делать commit. Стоит в случае:

* Создан новый функционал
* Добавлен новый блок на верстке
* Исправлены ошибки по коду
* Вы завершили рабочий день и хотите сохранить код

Это поможет держать ветки в порядке и видеть историю изменений по каждому нововведению в проекте, а не по каждому файлу.

Если посмотреть на значок вкладки Git, то можно увидеть цифру 1 в синем кружке. Она означает, сколько файлов изменено и незакоммичено

![Скрин](/Picture1.png)

Существует два вида файлов, в зависимости от вида разные операции:
1. *modified file* - git add, git commit -m, git commit am
2. *untracked file* - git add (неотслеживаемый файл, поэтому нужно сделать отслеживаемым)

Репозиторий это не папка, его нужно создать и иницианализировать

Репозиторий отслеживает изменения во всех вложенных в него папках

Созание репозитория возможно двумя способами:
1. При нахождении в папке, используем команду git init
2. Клонирование из GitHub с помощью команды git clone

При работе в терминале нужно внимательно следить за названием папки в командной строке, это должна быть папка проекта, репозиторий в котором работает

Нельзя создавать репозитории внутри репозитория

При необходимости можно сделать репозиторий обычной папкой, для этого нужно будет удалить скрытые файлы в папке репозитория

Фотографии и большие файлы не принято добавлять в систему контроля версий. Обычно добавляются только тестовые файлы и исходный код. Для игнорирования данных файлов Git-ом нужно добавить файл **.gitignore**, в котором указываются все файлы, не нуждающиеся в контроле версий, с указанием разрешений. Затем файл .gitignore трекается и коммитится

> Для тренировки работы в Git есть полезный сайт:
https://learngitbranching.js.org/?locale=ru_RU

Интересный факт): часто репозиторий разработчики называют "репой"

Полезно создать публичный репозиторий на GitHub со своим именем, в котором находится файл README.md (принято писать Caps lock-ом) с указанием сведений о тебе, то есть представиться.

Subversion (также известная как «SVN») — свободная централизованная система управления версиями, официально выпущенная в 2004 году компанией CollabNet. С 2010 года Subversion является одним из проектов Apache Software Foundation и официально называется Apache Subversion
Цель проекта в начале разработки — заменить распространённую на тот момент систему Concurrent Versions System (CVS), которая на сегодняшний день считается морально устаревшей. Subversion обладает всеми основными функциями CVS и избавлена от ряда недостатков последней.

>***Полезные ссылки по работе с Git!***

>https://habr.com/ru/post/541258/\
https://habr.com/ru/post/542616/\
https://github.com/netology-code/guides/blob/master/git-basics/GitCommandGuide.md
https://www.atlassian.com/ru/git/tutorials/setting-up-a-repository
https://www.atlassian.com/ru/git/tutorials/saving-changes
https://www.atlassian.com/ru/git/tutorials/inspecting-a-repository
https://www.atlassian.com/ru/git/tutorials/undoing-changes


# ***`Язык разметки Markdown`***

Markdown — это облегченный язык разметки с синтаксисом форматирования обычного текста

Знаки пунктуации:
* левая (открывающая) кавычка: &#8220;
* правая (закрывающая) кавычка: &#8221;
* правая закрывающая одинарная кавычка или апостроф: &#8217;
* левая открывающая одинарная кавычка (используется редко): &#8216;

> Блок цитирования

*Курсив*

\*Нет курсива\*

_Тоже курсив_

__Жирный__

**Тоже жирный** 

***Жирный курсив***

~~Перечеркнутый текст~~

Использование разных символов для курсива и жирного позволяет в рамках одного текста *сделать часть __жирным__  часть наклонным.*

----
***
___
это линии



* список ненумерованный
+ тоже список ненумерованный
- и это тоже список ненумерованный

1. список нумерованный
8. список нумерованный
891. список нумерованный (неважно какое число, делает по порядку)

- Пункт 1
    - Пункт 1.1
        - Пунк 1.1.1
* Пункт 2
    + Пункт 2.1

Следующий текст `обрамлен`
